use lexer;
use lexer::TokenType as TT;
use parser::ast;
use std::borrow::Cow;
use std::str::FromStr;
use parser::string_literal::parse_literal;

grammar<'input>;

pub seal = Module;

Module: () = {
    Item* => (),
};

Item: () = {
    LF => (),
    Function => (),
};

Function: () = {
    "fn" Identifier "(" Comma<Identifier> ")" Scope => ()
};

Scope: () = {
    LF? "{" (Statement End)* Statement? "}" => ()
};

Statement: () = {
    VariableDecl => (),
    AssignmentOp => (),
    Expression => (),
};

VariableDecl: () = {
    "let" DeclPattern ("=" Expression)? => (),
};

AssignmentOp: () = {
    AssignPattern AssignOps Expression => (),
};

Expression: () = {
    Scope => (),
    Lambda,
    BinaryOperators,
    
    IfExpression,
    LoopExpression,
    WhileExpression,
};

IfExpression: () = {
    "if" Expression Scope ElseTail? => (),
    "if" VariableDecl Scope ElseTail? => (),
};

ElseTail: () = {
    "else" IfExpression => (),
    "else" Scope => (),
};

LoopExpression: () = {
    (Label ":")? "loop" Scope => (),
};

WhileExpression: () = {
    (Label ":")? "while" Expression Scope WhileElse? => (),
    (Label ":")? "while" VariableDecl Scope WhileElse? => (),
};

WhileElse: () = {
    "else" Scope => (),
};

Lambda: () = {
    LambdaHeader Expression => (),
};

// Returns the list of parameter names
LambdaHeader: Vec<&'input str> = {
    "||" => vec![],
    "|" <Comma<Identifier>> "|",
};

AssignOps: ast::AssignOp = {
    "=" => ast::AssignOp::Assign,
    "||=" => ast::AssignOp::LogicalOr,
    "&&=" => ast::AssignOp::LogicalAnd,
    "|=" => ast::AssignOp::BitOr,
    "&=" => ast::AssignOp::BitAnd,
    "^=" => ast::AssignOp::BitXor,
    "<<=" => ast::AssignOp::LShiftLeft,
    ">>=" => ast::AssignOp::AShiftRight,
    ">>>=" => ast::AssignOp::LShiftRight,
    "+=" => ast::AssignOp::Add,
    "-=" => ast::AssignOp::Sub,
    "*=" => ast::AssignOp::Mul,
    "/=" => ast::AssignOp::Div,
    "%=" => ast::AssignOp::Rem,
    "mod=" => ast::AssignOp::Mod,
};

ImplOp: ast::BinOp = {
    "impls" => ast::BinOp::Implements,
};

RangeOps: ast::BinOp = {
    ".." => ast::BinOp::RangeExclusive,
    "..." => ast::BinOp::RangeInclusive,
};

LogicalOr: ast::BinOp = {
    "||" => ast::BinOp::LogicalOr
};

LogicalAnd: ast::BinOp = {
    "&&" => ast::BinOp::LogicalAnd
};

EqualOps: ast::BinOp = {
    "==" => ast::BinOp::Equal,
    "!=" => ast::BinOp::NotEqual,
    "<" => ast::BinOp::LessThan,
    ">" => ast::BinOp::GreaterThan,
    "<=" => ast::BinOp::LessOrEqual,
    ">=" => ast::BinOp::GreaterOrEqual,
};

BitOps: ast::BinOp = {
    "&" => ast::BinOp::BitAnd,
    "|" => ast::BinOp::BitOr,
    "^" => ast::BinOp::BitXor,
};

ShiftOps: ast::BinOp = {
    "<<" => ast::BinOp::LShiftLeft,
    ">>" => ast::BinOp::AShiftRight,
    ">>>" => ast::BinOp::LShiftRight,
};

AddSubOps: ast::BinOp = {
    "+" => ast::BinOp::Add,
    "-" => ast::BinOp::Sub,
};

MulDivOps: ast::BinOp = {
    "*" => ast::BinOp::Mul,
    "/" => ast::BinOp::Div,
    "%" => ast::BinOp::Rem,
    "/%" => ast::BinOp::DivRem,
    "mod" => ast::BinOp::Mod,
};

BinaryOperators = ImplOperator;
ImplOperator = Tier<ImplOp, RangeOperators>;
RangeOperators = Tier<RangeOps, LogicalOperators>;
LogicalOperators = Tier<LogicalOr, Tier<LogicalAnd, EqualityOperators>>;
EqualityOperators = Tier<EqualOps, BitwiseOperators>;
BitwiseOperators = Tier<BitOps, ShiftOperators>;
ShiftOperators = Tier<ShiftOps, AddSubOperators>;
AddSubOperators = Tier<AddSubOps, MulDivOperators>;
MulDivOperators = Tier<MulDivOps, UnaryOperators>;

UnaryOperators: () = {
    "-" UnaryOperators => (),
    "!" UnaryOperators => (),
    Dereference "?" => (),

    Dereference,
};

Dereference = DereferenceImp<Term>;
DereferenceImp<N>: () = {
    Dereference "." Identifier => (),
    Dereference "." DecIntegerLiteral => (), // tuple access
    Dereference "(" Comma<Expression> ")" => (),
    Dereference "[" Comma<Expression> "]" => (),
    N,
};

TypeName: () = {
    (Identifier ".")* Identifier => (),
};

Term: () = {
    "(" Expression ")" => (),
    Identifier => (),
    Literal Identifier? => (),
    Tuple => (),
    "nil" => (),
};

DeclPattern: () = {
    Identifier,
    "(" Comma<DeclPattern> ".."? ")" => (),
    "[" Comma<DeclPattern> ".."? "]" => (),
    "<" Comma<Identifier> ".."? ">" => (),
    "{" Comma<(Identifier (":" DeclPattern)?)> "}" => (),
};

AssignPattern: () = {
    DereferenceImp<Identifier> => (),
};

Tuple: () = {
    "(" ")" => (), // empty tuple
    "(" Expression "," Comma<Expression> ")" => () // normal tuple
};

Literal: () = {
    IntegerLiteral => (),
    FloatLiteral => (),
    StringLiteral => (),
    SimdLiteral => (),
    ObjectLiteral => (),
};

ObjectLiteral: () = {
    "new" TypeName? "{" Comma<ObjectLiteralItem> "}" => (),
};

ObjectLiteralItem: () = {
    Identifier (":" Expression)? => (),
};

ArrayLiteral: () = {
    "[" Comma<Expression> "]" => (),
    "[" Expression ";" Expression "]" => (),
};

SimdLiteral: () = {
    "<" Comma<BitwiseOperators> ">" => (),
};

IntegerLiteral: i64 = {
    DecIntegerLiteral,
    HEX_LITERAL => i64::from_str_radix(&<>[2..], 16).unwrap(),
    OCT_LITERAL => i64::from_str_radix(&<>[2..], 8).unwrap(),
    BIN_LITERAL => i64::from_str_radix(&<>[2..], 2).unwrap(),
};

DecIntegerLiteral: i64 = {
    INT_LITERAL => i64::from_str_radix(<>, 10).unwrap(),
};

FloatLiteral: f64 = {
    FLOAT_LITERAL => f64::from_str(<>).unwrap(),
};

// TODO: Parse string literal into actual string data
StringLiteral: Cow<'input, str> = {
    STR_LITERAL => {
        let lit = parse_literal(<>).unwrap();
        println!("Parsed string literal as {:?}", lit);
        lit
    }
};

Identifier: &'input str = IDENTIFIER => <>;
Label: &'input str = LABEL => &<>[1..];

End: () = {
    LF => (),
    ";" => (),
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Tier<Op, NextTier>: () = {
    Tier<Op, NextTier> Op NextTier => (),
    NextTier
};

extern {
    type Location = lexer::Location;
    type Error = lexer::LexicalError;

    enum lexer::Tok<'input> {
        "break" => (TT::Break, <&'input str>),
        "const" => (TT::Const, <&'input str>),
        "continue" => (TT::Continue, <&'input str>),
        "else" => (TT::Else, <&'input str>),
        "enum" => (TT::Enum, <&'input str>),
        "extern" => (TT::Extern, <&'input str>),
        "fn" => (TT::Function, <&'input str>),
        "for" => (TT::For, <&'input str>),
        "if" => (TT::If, <&'input str>),
        "impl" => (TT::Impl, <&'input str>),
        "impls" => (TT::Impls, <&'input str>),
        "in" => (TT::In, <&'input str>),
        "let" => (TT::Let, <&'input str>),
        "loop" => (TT::Loop, <&'input str>),
        "mod" => (TT::Mod, <&'input str>),
        "new" => (TT::New, <&'input str>),
        "nil" => (TT::Nil, <&'input str>),
        "return" => (TT::Return, <&'input str>),
        "throw" => (TT::Throw, <&'input str>),
        "trait" => (TT::Trait, <&'input str>),
        "type" => (TT::Type, <&'input str>),
        "use" => (TT::Use, <&'input str>),
        "while" => (TT::While, <&'input str>),

        "{" => (TT::OpenCurly, <&'input str>),
        "}" => (TT::CloseCurly, <&'input str>),
        "(" => (TT::OpenParen, <&'input str>),
        ")" => (TT::CloseParen, <&'input str>),
        "[" => (TT::OpenBracket, <&'input str>),
        "]" => (TT::CloseBracket, <&'input str>),
        ";" => (TT::Semicolon, <&'input str>),
        ":" => (TT::Colon, <&'input str>),
        "," => (TT::Comma, <&'input str>),
        "?" => (TT::Question, <&'input str>),
        "." => (TT::Dot, <&'input str>),

        ".." => (TT::RangeExclusive, <&'input str>),
        "..." => (TT::RangeInclusive, <&'input str>),

        "==" => (TT::Equal, <&'input str>),
        "!=" => (TT::NotEqual, <&'input str>),
        "<" => (TT::LessThan, <&'input str>),
        "<=" => (TT::LessOrEqual, <&'input str>),
        ">" => (TT::GreaterThan, <&'input str>),
        ">=" => (TT::GreaterOrEqual, <&'input str>),

        "!" => (TT::Not, <&'input str>),
        "~" => (TT::Tilde, <&'input str>),
        "@" => (TT::At, <&'input str>),

        "&&" => (TT::LogicalAnd, <&'input str>),
        "||" => (TT::LogicalOr, <&'input str>),
        "&&=" => (TT::LogicalAndAssign, <&'input str>),
        "||=" => (TT::LogicalOrAssign, <&'input str>),

        "+" => (TT::Add, <&'input str>),
        "-" => (TT::Sub, <&'input str>),
        "*" => (TT::Mul, <&'input str>),
        "/" => (TT::Div, <&'input str>),
        "%" => (TT::Rem, <&'input str>),
        "/%" => (TT::DivRem, <&'input str>),
        "&" => (TT::BitAnd, <&'input str>),
        "|" => (TT::BitOr, <&'input str>),
        "^" => (TT::BitXor, <&'input str>),
        "<<" => (TT::Shl, <&'input str>),
        ">>" => (TT::Shr, <&'input str>),
        ">>>" => (TT::LShr, <&'input str>),

        "=" => (TT::Assign, <&'input str>),
        "+=" => (TT::AddAssign, <&'input str>),
        "-=" => (TT::SubAssign, <&'input str>),
        "*=" => (TT::MulAssign, <&'input str>),
        "/=" => (TT::DivAssign, <&'input str>),
        "%=" => (TT::RemAssign, <&'input str>),
        "&=" => (TT::BitAndAssign, <&'input str>),
        "|=" => (TT::BitOrAssign, <&'input str>),
        "^=" => (TT::BitXorAssign, <&'input str>),
        "<<=" => (TT::ShlAssign, <&'input str>),
        ">>=" => (TT::ShrAssign, <&'input str>),
        ">>>=" => (TT::LShrAssign, <&'input str>),
        "mod=" => (TT::ModAssign, <&'input str>),

        LF => (TT::NewLine, <&'input str>),
        DOC_COMMENT => (TT::DocComment, <&'input str>),
        MOD_DOC_COMMENT => (TT::ModuleDocComment, <&'input str>),
        IDENTIFIER => (TT::Identifier, <&'input str>),
        INT_LITERAL => (TT::IntLiteral, <&'input str>),
        HEX_LITERAL => (TT::HexLiteral, <&'input str>),
        OCT_LITERAL => (TT::OctLiteral, <&'input str>),
        BIN_LITERAL => (TT::BinLiteral, <&'input str>),
        FLOAT_LITERAL => (TT::FloatLiteral, <&'input str>),
        STR_LITERAL => (TT::StringLiteral, <&'input str>),
        CHAR_LITERAL => (TT::CharLiteral, <&'input str>),
        LABEL => (TT::Label, <&'input str>),
    }
}
