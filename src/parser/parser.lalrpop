use lexer;
use lexer::TokenType as TT;
use parser::ast;
use parser::string_literal::parse_literal;
use std::borrow::Cow;
use std::str::FromStr;
use std::collections::BTreeMap;

grammar<'input>;

pub seal = Module;

Module: () = {
    MOD_DOC_COMMENT* LF* (Item End*)* => (),
};

Item: () = {
    Attributes InnerItem => (),
};

Attributes: () = {
    (RootAttribute LF+)* => (),
};

RootAttribute: () = {
    "@" <Attribute>,
    DOC_COMMENT => (),
};

Attribute: () = {
    Identifier "(" Comma<Attribute> ")" => (),
    Identifier ("=" Attribute)? => (),
    Literal => (),
};

InnerItem: () = {
    UseImport => (),
    Impl => (),
    TypeDecl => (),
    StructDecl => (),
    TraitDecl => (),
    EnumDecl => (),
    Constant => (),
    Function => (),
    ModDecl => (),
};

UseImport: () = {
    "use" Identifier ("." Identifier)* => (),
    "use" Identifier ("." Identifier)* "." "*" => (),
    "use" Identifier ("." Identifier)* "." "(" Comma<Identifier> ")" => (),
};

ModDecl: () = {
    "mod" Identifier => (),
    "mod" Identifier "{" Module "}" => (),
};

ExternImport: () = {
    "extern" "mod" Identifier => (),
};

Impl: () = {
    "impl" (TypeName "for")? TypeName "{" Module "}" => (),
};

TypeDecl: () = {
    "type" Identifier => (),
};

StructDecl: () = {
    "struct" Identifier "{" StructMembers "}" => (),
};

StructMembers: () = {
    LF* (StructMember "," LF*)* => (),
};

StructMember: () = {
    Attributes Identifier => (),
};

EnumDecl: () = {
    "enum" Identifier "{" EnumItems "}" => (),
};

EnumItems: () = {
    LF* (EnumItem "," LF*)* => (),
};

EnumItem: () = {
    Attributes Identifier ("(" Comma<Identifier> ")")? => (),
};

TraitDecl: () = {
    "trait" Identifier "{" TraitItems "}" => (),
};

TraitItems: () = {
    LF* (TraitItem End*)* => (),
};

TraitItem: () = {
    Attributes "fn" Identifier "(" Comma<Identifier> ")" => (),
};

Constant: () = {
    "const" Identifier "=" Expression End => (),
};

Function: () = {
    "fn" Identifier "(" Comma<Identifier> ")" Scope => (),
    "fn" "new" "(" Comma<Identifier> ")" Scope => (), // ctor
};

Scope: ast::Scope<'input> = {
    "{" <(<Statement> End)*> <Statement?> "}" => {
        let (mut v, e) = (<>);
        match e {
            Some(e) => v.push(e),
            None => (),
        }
        ast::Scope {
            statements: v,
        }
    }
};

Statement: ast::Statement<'input> = {
    VariableDecl => ast::Statement::VariableDecl(Box::new(<>)),
    Expression => ast::Statement::Expression(<>),
};

VariableDecl: ast::VariableDecl<'input> = {
    "let" <DeclPattern> <("=" <Expression>)?> => {
        let (p, e) = (<>);
        ast::VariableDecl {
            pattern: p,
            expression: e,
        }
    },
};

DeclPattern: ast::DeclPattern<'input> = {
    Identifier => ast::DeclPattern::Identifier(<>),
    "(" <Comma<DeclPattern>> <".."?> ")" => {
        let (v, b) = (<>);
        ast::DeclPattern::Tuple(v, b.is_some())
    },
    "[" <Comma<DeclPattern>> <".."?> "]" => {
        let (v, b) = (<>);
        ast::DeclPattern::Array(v, b.is_some())
    },
    "<" <Comma<Identifier>> <".."?> ">" => {
        let (v, b) = (<>);
        ast::DeclPattern::Simd(v, b.is_some())
    },
    "{" <Comma<(Identifier (":" <DeclPattern>)?)>> "}" => {
        ast::DeclPattern::Object(<>.into_iter().collect())
    },
};

Expression: ast::Expression<'input> = {
    Scope => ast::Expression::Scope(Box::new(<>)),
    Lambda => ast::Expression::Lambda(Box::new(<>)),
    BinaryOperators,
    
    AssignmentOp,
    Throw,
    Break,
    Continue,
    Return,
    IfExpression => ast::Expression::Literal(Box::new(ast::Literal::Nil)),
    MatchExpression => ast::Expression::Literal(Box::new(ast::Literal::Nil)),
    LoopExpression => ast::Expression::Literal(Box::new(ast::Literal::Nil)),
    WhileExpression => ast::Expression::Literal(Box::new(ast::Literal::Nil)),
    ForExpression => ast::Expression::Literal(Box::new(ast::Literal::Nil)),
};

AssignmentOp: ast::Expression<'input> = {
    AssignPattern AssignOps Expression => {
        let (lhs, op, rhs) = (<>);
        ast::Expression::AssignmentOp(Box::new(ast::AssignmentOp {
            lhs: lhs,
            rhs: rhs,
            operator: op,
        }))
    },
};

AssignPattern: ast::Expression<'input> = {
    DereferenceImp<IdentifierExpr>,
};

Throw: ast::Expression<'input> = {
    "throw" <Expression> => ast::Expression::Throw(Box::new(<>)),
};

Break: ast::Expression<'input> = {
    "break" <Label?> <(":" <Expression>)?> => {
        let (l, v) = (<>);
        ast::Expression::Break(Box::new(ast::Break {
            label: l,
            value: v,
        }))
    },
};

Continue: ast::Expression<'input> = {
    "continue" <Label?> <(":" <Expression>)?> => {
        let (l, v) = (<>);
        ast::Expression::Continue(Box::new(ast::Continue {
            label: l,
            value: v,
        }))
    },
};

Return: ast::Expression<'input> = {
    "return" <Expression> => ast::Expression::Return(Box::new(<>)),
};

IfExpression: () = {
    "if" Expression Scope ElseTail? => (),
    "if" "let" MatchPattern "=" Expression Scope ElseTail? => (),
};

ElseTail: () = {
    "else" IfExpression => (),
    "else" Scope => (),
};

MatchExpression: () = {
    "match" Expression "{" Comma<MatchItem> "}" => (),
};

MatchItem: () = {
    MatchPattern "=>" Expression => (),
};

MatchPattern: () = {
    Identifier,
    SimpleLiteral,
    (Identifier ("." Identifier)*)? "(" Comma<MatchPattern> ".."? ")" => (),
    (Identifier ("." Identifier)*)? "{" Comma<(Identifier (":" DeclPattern)?)> "}" => (),
    "[" Comma<MatchPattern> ".."? "]" => (),
    "<" Comma<Identifier> ".."? ">" => (),
};

LoopExpression: () = {
    (Label ":")? "loop" Scope => (),
};

WhileExpression: () = {
    (Label ":")? "while" Expression Scope LoopElse? => (),
    (Label ":")? "while" "let" MatchPattern "=" Expression Scope LoopElse? => (),
};

ForExpression: ast::ForLoop<'input> = {
    (<Label> ":")? "for" DeclPattern "in" Expression Scope LoopElse? => {
        let (label, _, binding, _, expr, body, elseb) = (<>);
        ast::ForLoop {
            label: label,
            binding: binding,
            expression: expr,
            body: body,
            else_body: elseb,
        }
    },
};

LoopElse = "else" <Scope>;

Lambda: ast::Lambda<'input> = {
    LambdaHeader Expression => {
        let (p, b) = (<>);
        ast::Lambda {
            parameters: p,
            body: b,
        }
    },
};

// Returns the list of parameter names
LambdaHeader: Vec<&'input str> = {
    "||" => vec![],
    "|" <Comma<Identifier>> "|",
};

AssignOps: ast::AssignOp = {
    "=" => ast::AssignOp::Assign,
    "||=" => ast::AssignOp::LogicalOr,
    "&&=" => ast::AssignOp::LogicalAnd,
    "|=" => ast::AssignOp::BitOr,
    "&=" => ast::AssignOp::BitAnd,
    "^=" => ast::AssignOp::BitXor,
    "<<=" => ast::AssignOp::LShiftLeft,
    ">>=" => ast::AssignOp::AShiftRight,
    ">>>=" => ast::AssignOp::LShiftRight,
    "+=" => ast::AssignOp::Add,
    "-=" => ast::AssignOp::Sub,
    "*=" => ast::AssignOp::Mul,
    "/=" => ast::AssignOp::Div,
    "%=" => ast::AssignOp::Rem,
    "mod=" => ast::AssignOp::Mod,
};

ImplOp: ast::BinOp = {
    "impls" => ast::BinOp::Implements,
};

RangeOps: ast::BinOp = {
    ".." => ast::BinOp::RangeExclusive,
    "..." => ast::BinOp::RangeInclusive,
};

LogicalOr: ast::BinOp = {
    "||" => ast::BinOp::LogicalOr
};

LogicalAnd: ast::BinOp = {
    "&&" => ast::BinOp::LogicalAnd
};

EqualOps: ast::BinOp = {
    "==" => ast::BinOp::Equal,
    "!=" => ast::BinOp::NotEqual,
    "<" => ast::BinOp::LessThan,
    ">" => ast::BinOp::GreaterThan,
    "<=" => ast::BinOp::LessOrEqual,
    ">=" => ast::BinOp::GreaterOrEqual,
};

BitOps: ast::BinOp = {
    "&" => ast::BinOp::BitAnd,
    "|" => ast::BinOp::BitOr,
    "^" => ast::BinOp::BitXor,
};

ShiftOps: ast::BinOp = {
    "<<" => ast::BinOp::LShiftLeft,
    ">>" => ast::BinOp::AShiftRight,
    ">>>" => ast::BinOp::LShiftRight,
};

AddSubOps: ast::BinOp = {
    "+" => ast::BinOp::Add,
    "-" => ast::BinOp::Sub,
};

MulDivOps: ast::BinOp = {
    "*" => ast::BinOp::Mul,
    "/" => ast::BinOp::Div,
    "%" => ast::BinOp::Rem,
    "/%" => ast::BinOp::DivRem,
    "mod" => ast::BinOp::Mod,
};

BinaryOperators = ImplOperator;
ImplOperator = Tier<ImplOp, RangeOperators>;
RangeOperators = Tier<RangeOps, LogicalOperators>;
LogicalOperators = Tier<LogicalOr, Tier<LogicalAnd, EqualityOperators>>;
EqualityOperators = Tier<EqualOps, BitwiseOperators>;
BitwiseOperators = Tier<BitOps, ShiftOperators>;
ShiftOperators = Tier<ShiftOps, AddSubOperators>;
AddSubOperators = Tier<AddSubOps, MulDivOperators>;
MulDivOperators = Tier<MulDivOps, UnaryOperators>;

UnaryOperators: ast::Expression<'input> = {
    "-" <UnaryOperators> => ast::Expression::Negate(Box::new(<>)),
    "!" <UnaryOperators> => ast::Expression::Not(Box::new(<>)),
    <Dereference> "?" => ast::Expression::Try(Box::new(<>)),

    Dereference,
};

Dereference = DereferenceImp<Term>;
DereferenceImp<N>: ast::Expression<'input> = {
    <Dereference> "." <Identifier> => {
        let (lhs, rhs) = (<>);
        ast::Expression::MemberAccess(Box::new(ast::MemberAccess {
            lhs: lhs,
            rhs: rhs,
        }))
    },
    <Dereference> "." <DecIntegerLiteral> => {
        let (lhs, rhs) = (<>);
        ast::Expression::TupleAccess(Box::new(ast::TupleAccess {
            lhs: lhs,
            rhs: rhs,
        }))
    },
    <Dereference> "(" <Comma<Expression>> ")" => {
        let (lhs, rhs) = (<>);
        ast::Expression::FunctionCall(Box::new(ast::FunctionCall {
            lhs: lhs,
            parameters: rhs,
        }))
    },
    <Dereference> "[" <Comma<Expression>> "]" => {
        let (lhs, rhs) = (<>);
        ast::Expression::ArrayIndex(Box::new(ast::ArrayIndex {
            lhs: lhs,
            indices: rhs,
        }))
    },
    N,
};

TypeName: ast::TypeName<'input> = {
    (<Identifier> ".")* Identifier => {
        let (mut v, i) = (<>);
        v.push(i);
        ast::TypeName {
            parts: v,
        }
    },
};

Term: ast::Expression<'input> = {
    "(" <Expression> ")",
    IdentifierExpr,
    Literal Identifier? => {
        let (e, i) = (<>);
        match i {
            None => ast::Expression::Literal(Box::new(e)),
            Some(i) => ast::Expression::UserSuffix(Box::new(ast::UserSuffix {
                value: e,
                suffix: i,
            })),
        }
    },
    Tuple,
};

Tuple: ast::Expression<'input> = {
    "(" ")" => ast::Expression::EmptyTuple, // empty tuple
    "(" <Expression> "," <Comma<Expression>> ")" => {
        let (e, mut v) = (<>);
        v.insert(0, e);
        ast::Expression::Tuple(Box::new(v))
    }
};

Literal: ast::Literal<'input> = {
    SimpleLiteral,
    SimdLiteral,
    ObjectLiteral,
    ArrayLiteral,
};

SimpleLiteral: ast::Literal<'input> = {
    IntegerLiteral => ast::Literal::Integer(<>),
    FloatLiteral => ast::Literal::Float(<>),
    StringLiteral => ast::Literal::String(<>),
    Label => ast::Literal::Label(<>),
    "nil" => ast::Literal::Nil,
};

ObjectLiteral: ast::Literal<'input> = {
    "new" <TypeName?> "{" <Comma<ObjectLiteralItem>> "}" => {
        let (ty, items) = (<>);
        let mut map = BTreeMap::new();
        for (k, v) in items {
            map.insert(k, v);
        }
        ast::Literal::ObjectLiteral(ty, map)
    },
};

ObjectLiteralItem: (&'input str, Option<ast::Expression<'input>>) = {
     LF* <Identifier> <(":" <Expression>)?> LF* => (<>),
};

ArrayLiteral: ast::Literal<'input> = {
    "[" <Comma<Expression>> "]" => ast::Literal::ArrayLiteral(<>),
    "[" <Expression> ";" <Expression> "]" => ast::Literal::ArraySplat(<>),
};

SimdLiteral: ast::Literal<'input> = {
    "<" <Comma<BitwiseOperators>> ">" => ast::Literal::SimdLiteral(<>),
};

IntegerLiteral: i64 = {
    DecIntegerLiteral,
    HEX_LITERAL => i64::from_str_radix(&<>[2..], 16).unwrap(),
    OCT_LITERAL => i64::from_str_radix(&<>[2..], 8).unwrap(),
    BIN_LITERAL => i64::from_str_radix(&<>[2..], 2).unwrap(),
};

DecIntegerLiteral: i64 = {
    INT_LITERAL => i64::from_str_radix(<>, 10).unwrap(),
};

FloatLiteral: f64 = {
    FLOAT_LITERAL => f64::from_str(<>).unwrap(),
};

// TODO: Parse string literal into actual string data
StringLiteral: Cow<'input, str> = {
    STR_LITERAL => {
        let lit = parse_literal(<>).unwrap();
        //println!("Parsed string literal as {:?}", lit);
        lit
    }
};

Identifier: &'input str = IDENTIFIER => <>;
Label: &'input str = LABEL => &<>[1..];

IdentifierExpr: ast::Expression<'input> = {
    Identifier => ast::Expression::NamedReference(<>),
};

End: () = {
    LF => (),
    ";" => (),
};

Comma<T>: Vec<T> = {
    <v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Tier<Op, NextTier>: ast::Expression<'input> = {
    Tier<Op, NextTier> Op NextTier => {
        let (lhs, op, rhs) = (<>);
        let op = ast::BinaryOp {
            lhs: lhs,
            rhs: rhs,
            operator: op
        };
        ast::Expression::BinaryOp(Box::new(op))
    },
    NextTier
};

extern {
    type Location = lexer::Location;
    type Error = lexer::LexicalError;

    enum lexer::Tok<'input> {
        "break" => (TT::Break, <&'input str>),
        "const" => (TT::Const, <&'input str>),
        "continue" => (TT::Continue, <&'input str>),
        "else" => (TT::Else, <&'input str>),
        "enum" => (TT::Enum, <&'input str>),
        "extern" => (TT::Extern, <&'input str>),
        "fn" => (TT::Function, <&'input str>),
        "for" => (TT::For, <&'input str>),
        "if" => (TT::If, <&'input str>),
        "impl" => (TT::Impl, <&'input str>),
        "impls" => (TT::Impls, <&'input str>),
        "in" => (TT::In, <&'input str>),
        "let" => (TT::Let, <&'input str>),
        "loop" => (TT::Loop, <&'input str>),
        "match" => (TT::Match, <&'input str>),
        "mod" => (TT::Mod, <&'input str>),
        "new" => (TT::New, <&'input str>),
        "nil" => (TT::Nil, <&'input str>),
        "return" => (TT::Return, <&'input str>),
        "struct" => (TT::Struct, <&'input str>),
        "throw" => (TT::Throw, <&'input str>),
        "trait" => (TT::Trait, <&'input str>),
        "type" => (TT::Type, <&'input str>),
        "use" => (TT::Use, <&'input str>),
        "while" => (TT::While, <&'input str>),

        "{" => (TT::OpenCurly, <&'input str>),
        "}" => (TT::CloseCurly, <&'input str>),
        "(" => (TT::OpenParen, <&'input str>),
        ")" => (TT::CloseParen, <&'input str>),
        "[" => (TT::OpenBracket, <&'input str>),
        "]" => (TT::CloseBracket, <&'input str>),
        ";" => (TT::Semicolon, <&'input str>),
        ":" => (TT::Colon, <&'input str>),
        "," => (TT::Comma, <&'input str>),
        "?" => (TT::Question, <&'input str>),
        "." => (TT::Dot, <&'input str>),
        "=>" => (TT::FatArrow, <&'input str>),

        ".." => (TT::RangeExclusive, <&'input str>),
        "..." => (TT::RangeInclusive, <&'input str>),

        "==" => (TT::Equal, <&'input str>),
        "!=" => (TT::NotEqual, <&'input str>),
        "<" => (TT::LessThan, <&'input str>),
        "<=" => (TT::LessOrEqual, <&'input str>),
        ">" => (TT::GreaterThan, <&'input str>),
        ">=" => (TT::GreaterOrEqual, <&'input str>),

        "!" => (TT::Not, <&'input str>),
        "~" => (TT::Tilde, <&'input str>),
        "@" => (TT::At, <&'input str>),

        "&&" => (TT::LogicalAnd, <&'input str>),
        "||" => (TT::LogicalOr, <&'input str>),
        "&&=" => (TT::LogicalAndAssign, <&'input str>),
        "||=" => (TT::LogicalOrAssign, <&'input str>),

        "+" => (TT::Add, <&'input str>),
        "-" => (TT::Sub, <&'input str>),
        "*" => (TT::Mul, <&'input str>),
        "/" => (TT::Div, <&'input str>),
        "%" => (TT::Rem, <&'input str>),
        "/%" => (TT::DivRem, <&'input str>),
        "&" => (TT::BitAnd, <&'input str>),
        "|" => (TT::BitOr, <&'input str>),
        "^" => (TT::BitXor, <&'input str>),
        "<<" => (TT::Shl, <&'input str>),
        ">>" => (TT::Shr, <&'input str>),
        ">>>" => (TT::LShr, <&'input str>),

        "=" => (TT::Assign, <&'input str>),
        "+=" => (TT::AddAssign, <&'input str>),
        "-=" => (TT::SubAssign, <&'input str>),
        "*=" => (TT::MulAssign, <&'input str>),
        "/=" => (TT::DivAssign, <&'input str>),
        "%=" => (TT::RemAssign, <&'input str>),
        "&=" => (TT::BitAndAssign, <&'input str>),
        "|=" => (TT::BitOrAssign, <&'input str>),
        "^=" => (TT::BitXorAssign, <&'input str>),
        "<<=" => (TT::ShlAssign, <&'input str>),
        ">>=" => (TT::ShrAssign, <&'input str>),
        ">>>=" => (TT::LShrAssign, <&'input str>),
        "mod=" => (TT::ModAssign, <&'input str>),

        LF => (TT::NewLine, <&'input str>),
        DOC_COMMENT => (TT::DocComment, <&'input str>),
        MOD_DOC_COMMENT => (TT::ModuleDocComment, <&'input str>),
        IDENTIFIER => (TT::Identifier, <&'input str>),
        INT_LITERAL => (TT::IntLiteral, <&'input str>),
        HEX_LITERAL => (TT::HexLiteral, <&'input str>),
        OCT_LITERAL => (TT::OctLiteral, <&'input str>),
        BIN_LITERAL => (TT::BinLiteral, <&'input str>),
        FLOAT_LITERAL => (TT::FloatLiteral, <&'input str>),
        STR_LITERAL => (TT::StringLiteral, <&'input str>),
        CHAR_LITERAL => (TT::CharLiteral, <&'input str>),
        LABEL => (TT::Label, <&'input str>),
    }
}
