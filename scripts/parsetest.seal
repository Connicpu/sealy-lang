fn main() {
    let x = foo()
        .goo()
    let y = 5

    foo(); boo()

    let (x, y) = (y, x)

    let { x, y } = bar()
    let <x, y> = baz()
    let <x, y, ..> = baq()
    let [(a, b), (c, d)] = qux()

    x += 1
    y += 2

    let z = (x mod y + 5)[0]

    foo()
    -x

    big.ass.expression.to.get.to.an.array[at, an, index]
        += my.awesome().value

    let w = <1, 2, 3>

    1_000

    90deg.to_rad()

    baz("asdf")
    bar("\u{1F98A}")

    let z = if foo() {
        bar()
    } else {
        1_000_000.dollars
    }

    while let x = baz() {
        print(x)
    } else {
        print("baz gives nothing")
    }

    if if a { b } else { c } {
        "lol"
    }

    if b {
        wow()
    } else {
        k()
    }

    if a
    {
        wow()
    }
    else
    {
        k()
    }

    loop
    {
        print("cool")
    }
}

type Degrees;
impl Degrees {
    @suffix('deg)
    fn new(value) {
        new Degrees { value }
    }

    fn to_rad(self) {
        new Radians { value: self.value * math.PI / 180.0 }
    }

    fn to_deg(self) {
        self
    }
}

type Radians;
impl Radians {
    @suffix('rad)
    fn new(value) {
        new Radians { value }
    }

    fn to_rad(self) {
        self
    }

    fn to_deg(self) {
        new Degrees { value: self.value * 180.0 / math.PI }
    }
}

fn foo() {
    math.sin(90deg.to_rad()) + math.cos(45deg.to_rad())
}

